const DateMagic = Date; DateMagic.prototype.format = function (format, locale = null, calendar = null) { locale = (locale || navigator.language || navigator.userLanguage || "en-US").split("-")[0], calendar = (calendar || navigator.calendar || "gregory").toLowerCase(); var calendar = { en: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], es: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], pt: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] }, dayNames = { en: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], es: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"], pt: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"] }, calendar = calendar[locale] || calendar.en, locale = dayNames[locale] || dayNames.en; const formatChars = { d: String(this.getDate()).padStart(2, "0"), D: locale[this.getDay()].slice(0, 3), j: this.getDate(), l: locale[this.getDay()], N: 0 === this.getDay() ? 7 : this.getDay(), S: ["st", "nd", "rd"][3 < (this.getDate() + "").slice(-1) || (this.getDate() + "").slice(-2) < 10 || 20 < (this.getDate() + "").slice(-2) && 0 == (this.getDate() + "").slice(-1) ? 0 : (this.getDate() + "").slice(-1) - 1], w: this.getDay(), z: Math.floor((this - new Date(this.getFullYear(), 0, 1)) / 864e5), W: (dayNames = new Date(this.valueOf()), locale = (this.getDay() + 6) % 7, dayNames.setDate(dayNames.getDate() - locale + 3), locale = dayNames.valueOf(), dayNames.setMonth(0, 1), 4 !== dayNames.getDay() && dayNames.setMonth(0, 1 + (4 - dayNames.getDay() + 7) % 7), 1 + Math.ceil((locale - dayNames) / 6048e5)), F: calendar[this.getMonth()], m: String(this.getMonth() + 1).padStart(2, "0"), M: calendar[this.getMonth()].slice(0, 3), n: this.getMonth() + 1, t: new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate(), L: this.getFullYear() % 4 == 0 && this.getFullYear() % 100 != 0 || this.getFullYear() % 400 == 0 ? 1 : 0, o: this.getFullYear() + (11 === this.getMonth() && this.getDate() < 29 ? 1 : 0 === this.getMonth() && 3 < this.getDate() ? -1 : 0), Y: this.getFullYear(), y: String(this.getFullYear()).slice(-2), a: this.getHours() < 12 ? "am" : "pm", A: this.getHours() < 12 ? "AM" : "PM", B: Math.floor(1e3 * ((this.getUTCHours() + 1) % 24 + this.getUTCMinutes() / 60 + this.getUTCSeconds() / 3600) / 24), g: this.getHours() % 12 || 12, G: this.getHours(), h: String(this.getHours() % 12 || 12).padStart(2, "0"), H: String(this.getHours()).padStart(2, "0"), i: String(this.getMinutes()).padStart(2, "0"), s: String(this.getSeconds()).padStart(2, "0"), u: String(this.getMilliseconds()).padStart(3, "0"), v: String(this.getMilliseconds()).padStart(3, "0"), e: Intl.DateTimeFormat().resolvedOptions().timeZone, I: this.getTimezoneOffset() === new Date(this.getFullYear(), 0, 1).getTimezoneOffset() ? 0 : 1, O: this.toTimeString().match(/([+-]\d{4})/)[1], P: (locale = this.toTimeString().match(/([+-]\d{2}):(\d{2})/)) ? locale[1] + ":" + locale[2] : "", p: (() => { var match = this.toTimeString().match(/([+-]\d{2}):(\d{2})/); return match ? match[1] + match[2] : "" })(), T: this.toTimeString().match(/[A-Z]+/)[0], Z: 60 * this.getTimezoneOffset() }; return "OPTIONS" === format ? [{ char: "d", meaning: "Day of the month, 2 digits with leading zeros (01 to 31)" }, { char: "D", meaning: "A textual representation of a day, three letters (Mon through Sun)" }, { char: "j", meaning: "Day of the month without leading zeros (1 to 31)" }, { char: "l", meaning: "A full textual representation of the day of the week (Sunday through Saturday)" }, { char: "N", meaning: "ISO-8601 numeric representation of the day of the week (1 for Monday, 7 for Sunday)" }, { char: "S", meaning: "English ordinal suffix for the day of the month, 2 characters (st, nd, rd or th)" }, { char: "w", meaning: "Numeric representation of the day of the week (0 for Sunday, 6 for Saturday)" }, { char: "z", meaning: "The day of the year (0 through 365)" }, { char: "W", meaning: "ISO-8601 week number of year, weeks starting on Monday" }, { char: "F", meaning: "A full textual representation of a month, such as January or March" }, { char: "m", meaning: "Numeric representation of a month, with leading zeros (01 to 12)" }, { char: "M", meaning: "A short textual representation of a month, three letters (Jan to Dec)" }, { char: "n", meaning: "Numeric representation of a month, without leading zeros (1 to 12)" }, { char: "t", meaning: "Number of days in the given month (28 to 31)" }, { char: "L", meaning: "Whether it's a leap year (1 if leap year, 0 otherwise)" }, { char: "o", meaning: "ISO-8601 year number, same as Y except if the ISO week number (W) belongs to the previous or next year" }, { char: "Y", meaning: "A full numeric representation of a year, 4 digits (e.g. 2022)" }, { char: "y", meaning: "A two-digit representation of a year (e.g. 22 for 2022)" }, { char: "a", meaning: "Lowercase Ante meridiem and Post meridiem (am or pm)" }, { char: "A", meaning: "Uppercase Ante meridiem and Post meridiem (AM or PM)" }, { char: "B", meaning: "Swatch Internet time (000 to 999)" }, { char: "g", meaning: "12-hour format of an hour without leading zeros (1 to 12)" }, { char: "G", meaning: "24-hour format of an hour without leading zeros (0 to 23)" }, { char: "h", meaning: "12-hour format of an hour with leading zeros (01 to 12)" }, { char: "H", meaning: "24-hour format of an hour with leading zeros (00 to 23)" }, { char: "i", meaning: "Minutes with leading zeros (00 to 59)" }, { char: "s", meaning: "Seconds with leading zeros (00 to 59)" }, { char: "u", meaning: "Microseconds (000000 to 999999)" }, { char: "v", meaning: "Milliseconds (000 to 999)" }, { char: "e", meaning: "Timezone identifier (e.g. UTC, GMT, Atlantic/Azores)" }, { char: "I", meaning: "Whether the date is in daylight saving time (DST) (1 if DST, 0 otherwise)" }, { char: "O", meaning: "Difference to Greenwich time (GMT) in hours (e.g. +0200)" }, { char: "P", meaning: "Difference to Greenwich time (GMT) with colon between hours and minutes (e.g. +02:00)" }, { char: "p", meaning: "Difference to Greenwich time (GMT) without colon between hours and minutes (e.g. +0200)" }, { char: "T", meaning: "Timezone abbreviation (e.g. EDT, CEST)" }, { char: "Z", meaning: "Timezone offset in seconds (-43200 to 50400)" }] : "ALL" === format ? formatChars : format.replace(/(d|D|j|l|N|S|w|z|W|F|m|M|n|t|L|o|Y|y|a|A|B|g|G|h|H|i|s|u|v|e|I|O|P|p|T|Z)/g, match => formatChars[match] || match) }; export default DateMagic; export { DateMagic };